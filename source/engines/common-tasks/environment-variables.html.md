---
title: Environment Variables
---

The engine is responsible for explicitly defining which environment variables are available to the live app.

#### Caution

At first this might seem confusing or misleading as services (such as mysql, postgresql, redis, etc) will auto-generate environment variables upon creation, and application developers can define environment variables in the [Boxfile](/engines/scripts/boxfile). Essentially, ALL auto-generated environment variables are given to the engine within the [payload](/engines/scripts/#payload). The engine has the authoritative responsibility to determine which of the environment variables provided should be exported in the build environment or persisted to be exported in the live environment.

Put another way, the environment variables generated by Nanobox will be given to the engine. The engine MUST export or persist all, any, or some of those variables before they can be accessible to the build environment or the live app.

## Rational

#### Purpose

Many of the environment variables provided to the engine have value to the build environment, but not in the live environment. For instance, an engine may use the `REDIS1_HOST` and `REDIS1_PORT` environment variable to configure a redis adapter configuration. This process should occur in the [build](/engines/scripts/build/) script. Once the application has been configured to connect to redis, the environment variables are no longer needed.

#### Security

Some environment variables contain sensitive information, like `POSTGRESQL1_USER` and `POSTGRESQL1_PASS`. After the application's database adapters have been configured during the build, leaving these environment variables in the live environment may pose a vulnerability.

## Approach

When approaching this scenario, an engine can do one of the following:

#### Pass-through

With a pass-through approach, the engine opts to persist all environment variables to the production environment. This is easy, and if security is not a concern for this type of application, may be the best option.

#### Whitelist

With this approach, the engine explicitly exports or persists environment variables with known keys. No keys outside of the approved list will be allowed.

#### Blacklist

With this approach, the engine exports or persists all environment variables EXCEPT those with known keys. No keys matching the list will be allowed.

#### Nothing

Technically this is the default behavior. Unless an engine explicitly exports or persists environment variables, the live application environment will not have environment variables.

## Export vs Persist

It is important for an engine developer to understand the difference between exporting an environment variable and persisting an environment variable. Keep in mind that the environment variables are not pre-exported to the build environment. Exporting an environment variable makes the variable available for the duration of the script, but does NOT make it available
to the live app. An environment variable must be persisted to be made available to the application.

In summary: exporting an environment variable makes that variable available for the duration of the running script. Persisting an environment variable makes that variable available to the running application. An environment variable must be both exported and persisted to be available to the build and live environment.

Check the [implementation](/engines/common-tasks/environment-variables/#implementation) below for details on how to export or persist an environment variable.

## Implementation

#### Where are the environment variables?

The available environment variables provided by Nanobox are given to the script in the [payload](/engines/scripts/#payload). The `env` node within the payload contains a hash of key/value pairs. This set of key/value pairs is the set of environment variables. Nos provides helper functions for convenience as described [below](/engines/common-tasks/environment-variables/#nos-helpers), which is the recommended approach. Here is an example of how to loop over the environment variables manually:

```bash
evars=$(payload 'env')
list=(${evars//,/ })

for evar in "${list[@]}"; do
  key=$evar
  val=$(payload "env_${evar}")
  echo "${key}:${val}"
done
```

#### How do I export them?

Exporting an environment variable is the same as exporting any variable in bash. Nos provides helper functions for convenience, as described [below](/engines/common-tasks/environment-variables/#nos-helpers). Here is an example of exporting an environment variable, assuming `$key` and `$val` are pre-defined, perhaps using the aforementioned example:

```bash
export "${key}=${val}"
```

#### How do I persist them?

The process of persisting an environment variable consists of creating a file in the [env_dir]() with the filename being the variable key, and the file contents being the variable data. Nos provides helper functions for convenience, as described [below](/engines/common-tasks/environment-variables/#nos-helpers). Here is an example of persisting an environment variable manually, assuming `$key` and `$val` are pre-defined, perhaps using the aforementioned example:

```bash
env_dir=$(payload 'env_dir')
echo $val > ${env_dir}/$key
```

## Nos Helpers

#### Exporting and persisting a single variable

Nos provides the functions `set_evar` and `persist_evar`, to export and persist accordingly. The functions expect two arguments: the key and the value.

Example:

```bash
set_evar "foo" "bar"
# or
persist_evar "foo" "bar"
```

#### Exporting and persisting all variables

Nos provides the functions `set_evars` and `persist_evars`, to export and persist all variables accordingly. The functions are called without any arguments.

Example:

```bash
set_evars
# or
persist_evars
```

#### Exporting and persisting all variables with a whitelist

Nos provides the functions `set_evars_whitelist` and `persist_evars_whitelist`, to export and persist all variables according to a whitelist. The functions expect a single argument, which is a regex to provide the whitelist.

Example:

```bash
whitelist="APP_NAME|MYSQL1_USER|MYSQL1_HOST|MYSQL1_PORT"
set_evars_whitelist "${whitelist}"
# or
persist_evars_whitelist "${whitelist}"
```

#### Exporting and persisting all variables with a blacklist

Nos provides the functions `set_evars_blacklist` and `persist_evars_blacklist`, to export and persist all variables according to a blacklist. The functions expect a single argument,
which is a regex to provide the blacklist.

Example:

```bash
blacklist=".+_PASS"
set_evars_blacklist "${blacklist}"
# or
persist_evars_blacklist "${blacklist}"
```
