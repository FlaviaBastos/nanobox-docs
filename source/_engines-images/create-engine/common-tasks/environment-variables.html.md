---
title: Environment Variables
---

The engine is responsible for explicitly defining which environment variables are available to the live app.

#### Caution

At first this might seem confusing or misleading as services (such as mysql, postgresql, redis, etc.) auto-generate environment variables upon creation, and application developers can [define environment variables in the Boxfile](/boxfile/env). Essentially, ALL auto-generated environment variables are given to the engine within the [payload](/engines/scripts/#payload). The engine has the authoritative responsibility to determine which environment variables provided should be included in the build environment and/or persisted and exported to the live environment.

**In short, the environment variables generated by Nanobox are made available to the engine. It is up to the engine to export and/or persist all, any, or some of those variables before they will be accessible to the build environment or the live app.**

## Rational

#### Purpose

Many environment variables provided to the engine have value in the build environment, but not in the live environment. For instance, an engine may use the `REDIS1_HOST` and `REDIS1_PORT` environment variable to configure a redis adapter configuration, which should occur in the [build](/engines/scripts/build/) script. Once the application has been configured to connect to Redis, the environment variables are no longer needed.

#### Security

Some environment variables contain sensitive information, like `POSTGRESQL1_USER` and `POSTGRESQL1_PASS`. After the application's database adapters have been configured during the build, including these environment variables in the live environment could constitute a security vulnerability.

## Approach

There are different approaches you can use when handling environment variables within an engine. An engine can do one of the following:

#### Pass-Through

With a pass-through approach, the engine opts to persist all environment variables to the production environment. If security is not a concern for the application, this is the easiest option. The pass-through approach using Nos helpers is outlined [below](#exporting-amp-persisting-all-variables).

#### Whitelist

With this approach, the engine explicitly exports or persists environment variables with known keys. No keys outside of the approved list are allowed. The whitelist approach using Nos helpers is outlined [below](#exporting-amp-persisting-all-variables-with-a-whitelist).

#### Blacklist

With this approach, the engine exports or persists all environment variables *EXCEPT* those with known keys. No keys matching the list will be allowed. The blacklist approach using Nos helpers is outlined [below](#exporting-amp-persisting-all-variables-with-a-blacklist).

#### Nothing

This is the default behavior. Unless an engine explicitly exports or persists environment variables, the live application environment will not have environment variables.

## Export vs Persist

It is important for an engine developer to understand the difference between exporting an environment variable and persisting an environment variable. Keep in mind that the environment variables are not pre-exported to the build environment. Exporting an environment variable makes the variable available for the duration of the script, but does NOT make it available to the live app. An environment variable must be persisted in order to be available to the live application.

**In summary:** exporting an environment variable makes that variable available for the duration of the running script. Persisting an environment variable makes that variable available to the running application. An environment variable must be both exported and persisted to be available to both the build and live environments.

Check the [implementation](#implementation) below for details on how to export or persist an environment variable.

## Implementation

#### Where are the environment variables?

Environment variables provided by Nanobox are made available to the script in the [payload](/engines/scripts/#payload). The `env` node within the payload contains a hash of key/value pairs. This set of key/value pairs is the set of environment variables.

Nos provides helper functions for convenience as described [below](#nos-helpers), which is the recommended approach. Here is an example of how to loop over the environment variables manually:

```bash
evars=$(payload 'env')
list=(${evars//,/ })

for evar in "${list[@]}"; do
  key=$evar
  val=$(payload "env_${evar}")
  echo "${key}:${val}"
done
```

#### How do I export them?

Exporting an environment variable is the same as exporting any variable in bash. Nos provides helper functions for convenience, as described [below](#nos-helpers). Here is an example of exporting an environment variable, assuming `$key` and `$val` are pre-defined, perhaps using the aforementioned example:

```bash
export "${key}=${val}"
```

#### How do I persist them?

The process of persisting an environment variable consists of creating a file in the [env_dir](/engines/scripts/#payload-data) with the filename being the variable key, and the file contents being the variable data. Nos provides helper functions for convenience, as described [below](/engines/common-tasks/environment-variables/#nos-helpers). Here is an example of persisting an environment variable manually, assuming `$key` and `$val` are pre-defined, perhaps using the aforementioned example:

```bash
env_dir=$(payload 'env_dir')
echo $val > ${env_dir}/$key
```

## Nos Helpers

#### Exporting and Persisting a Single Variable

Nos provides the functions `set_evar` and `persist_evar`, to export and persist accordingly. The functions expect two arguments: the key and the value.

###### Example:
```bash
set_evar "foo" "bar"
# or
persist_evar "foo" "bar"
```

#### Exporting & Persisting All Variables

Nos provides the functions `set_evars` and `persist_evars`, to export and persist all variables accordingly. The functions are called without any arguments.

###### Example:
```bash
set_evars
# or
persist_evars
```

#### Exporting & Persisting All Variables with a Whitelist

Nos provides the functions `set_evars_whitelist` and `persist_evars_whitelist`, to export and persist all variables according to a whitelist. The functions expect a single argument, which is a regex to provide the whitelist.

###### Example:
```bash
whitelist="APP_NAME|MYSQL1_USER|MYSQL1_HOST|MYSQL1_PORT"
set_evars_whitelist "${whitelist}"
# or
persist_evars_whitelist "${whitelist}"
```

#### Exporting & Persisting All Variables with a Blacklist

Nos provides the functions `set_evars_blacklist` and `persist_evars_blacklist`, to export and persist all variables according to a blacklist. The functions expect a single argument,
which is a regex to provide the blacklist.

###### Example:
```bash
blacklist=".+_PASS"
set_evars_blacklist "${blacklist}"
# or
persist_evars_blacklist "${blacklist}"
```
